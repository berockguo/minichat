/* logic_tool_impl.cpp

 Generated by phxrpc_pb2tool from logic.proto

*/

#include "logic_tool_impl.h"
#include "logic_client.h"

#include "phxrpc/file.h"

#include <random>     // random_device, uniform_int_distribution
#include <sstream>

#include "cert/pem_file.h"
#include "taocrypt/include/config.h"
#include "taocrypt/include/rsa.hpp"
#include "taocrypt/include/aes.hpp"

using namespace phxrpc;

LogicToolImpl:: LogicToolImpl()
{
}

LogicToolImpl:: ~LogicToolImpl()
{
}

int LogicToolImpl :: PHXEcho( phxrpc::OptMap & opt_map )
{
    google::protobuf::StringValue req;
    google::protobuf::StringValue resp;

    if( NULL == opt_map.Get( 's' ) ) return -1;

    req.set_value( opt_map.Get( 's' ) );

    LogicClient client;
    int ret = client.PHXEcho( req, &resp );
    printf( "%s return %d\n", __func__, ret );
    printf( "resp: {\n%s}\n", resp.DebugString().c_str() );

    return ret;
}

int LogicToolImpl :: Auth( phxrpc::OptMap & opt_map )
{
    logic::MiniRequest req;
    logic::MiniResponse resp;

    //TODO: fill req from opt_map

    if( NULL == opt_map.Get( 'u' ) || NULL == opt_map.Get( 'p' ) ) {
        return -1;
    }

    logic::ManualAuthReq manual_auth_req;;
    {
        req.mutable_head()->set_username( opt_map.Get( 'u' ) );
        req.mutable_head()->set_enc_algo( logic::ENC_NONE );

        manual_auth_req.set_pwd_md5( opt_map.Get( 'p' ) );

        std::random_device rd;
        std::stringstream fmt;
        fmt << rd() << rd();
        manual_auth_req.set_rand_key( fmt.str() );
    }

    logic::AuthRequest req_obj;
    {
        std::string tmp_buff;
        manual_auth_req.SerializeToString( &tmp_buff );

        TaoCrypt::RSA_PublicKey pub;
        PemFileUtils::LoadPubKey( "~/minichat/etc/client/minichat_pubkey.pem", &pub );

        TaoCrypt::RandomNumberGenerator rng;
        TaoCrypt::RSAES_Encryptor enc( pub );

        req_obj.mutable_manual_auth_req()->resize( pub.FixedCiphertextLength() );

        enc.Encrypt( (unsigned char*)tmp_buff.c_str(), tmp_buff.size(),
                (unsigned char*)req_obj.manual_auth_req().data(), rng);

        req_obj.SerializeToString( req.mutable_req_buff() );
    }

    LogicClient client;
    int ret = client.Auth( req, &resp );
    printf( "%s return %d\n", __func__, ret );
    printf( "resp: {\n%s}\n", resp.DebugString().c_str() );

    logic::AuthResponse resp_obj;
    if( 0 == ret ) {
        manual_auth_req.mutable_rand_key()->resize( 16 );

        std::string tmp_buff;
        tmp_buff.resize( resp.resp_buff().size() );

        TaoCrypt::AES_ECB_Decryption dec;
        dec.SetKey( (unsigned char*)manual_auth_req.rand_key().c_str(),
                manual_auth_req.rand_key().size() );

        dec.Process( (unsigned char*)tmp_buff.c_str(),
                (unsigned char*)resp.resp_buff().c_str(), resp.resp_buff().size() );

        resp_obj.ParseFromString( tmp_buff );

        printf( "resp: {\n%s}\n", resp_obj.DebugString().c_str() );
    }

    return ret;
}

int LogicToolImpl :: Sync( phxrpc::OptMap & opt_map )
{
    logic::MiniRequest req;
    logic::MiniResponse resp;

    //TODO: fill req from opt_map


    LogicClient client;
    int ret = client.Sync( req, &resp );
    printf( "%s return %d\n", __func__, ret );
    printf( "resp: {\n%s}\n", resp.DebugString().c_str() );

    return ret;
}

int LogicToolImpl :: SendMsg( phxrpc::OptMap & opt_map )
{
    logic::MiniRequest req;
    logic::MiniResponse resp;

    // fill req from opt_map

    if( NULL == opt_map.Get( 's' ) || NULL == opt_map.Get( 't' )
            || NULL == opt_map.Get( 'm' ) ) {
        return -1;
    }

    logic::SendMsgRequest req_obj;
    {
        req.mutable_head()->set_username( opt_map.Get( 's' ) );
        req.mutable_head()->set_enc_algo( logic::ENC_NONE );

        logic::MsgRequest * msg = req_obj.add_msg();
        msg->set_to( opt_map.Get( 't' ) );
        msg->set_content( opt_map.Get( 'm' ) );

        std::random_device rd;
        std::stringstream fmt;
        fmt << rd() << rd();
        msg->set_uuid( fmt.str() );
    }

    req_obj.SerializeToString( req.mutable_req_buff() );

    LogicClient client;
    int ret = client.SendMsg( req, &resp );

    printf( "%s return %d\n", __func__, ret );
    printf( "resp: {\n%s}\n", resp.DebugString().c_str() );

    if( 0 == ret && 0 == resp.ret() ) {
        logic::SendMsgResponse resp_obj;
        resp_obj.ParseFromString( resp.resp_buff() );

        printf( "result: {\n%s\n}\n", resp_obj.DebugString().c_str() );
    }

    return ret;
}

